/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/code_highlighter.js":
/*!********************************!*\
  !*** ./js/code_highlighter.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   transform: () => (/* binding */ transform)
/* harmony export */ });
const escapeRegExp = string => {
  return string.replace(/[\=|\.|\*|\+|\?|\^|\$|\{|\}|\(|\)|\[|\]|\\]/g, "\\$&");
};
const highlightKeywords = (text, keywordClasses) => {
  const keywordPattern = new RegExp(`${Object.keys(keywordClasses).map(escapeRegExp).join("|")}`, "gi");
  let text1 = text.replace(keywordPattern, match => {
    const cssClass = keywordClasses[match];
    return `<span class="${cssClass}">${match}</span>`;
  });
  return text1;
};
const keys = {
  "let ": "let",
  "const ": "const",
  "=": "sign",
  Winnetou: "winnetou",
  setMutable: "method",
  initMutable: "method",
  "(": "sign",
  ")": "sign",
  "+": "sign",
  ".": "sign",
  $: "sign2",
  "{": "sign2",
  "}": "sign2",
  "[": "sign2",
  "]": "sign2",
  create: "method",
  "&lt;": "sign2",
  "&gt;": "sign2",
  winnetou: "sign2",
  "import ": "const",
  "export ": "const",
  "default ": "method",
  "from ": "let"
};

/**
 * HIGHLIGHT CODE
 * @param {string} text
 * @returns {string}
 */
const transform = text => {
  return highlightKeywords(text, keys).trim();
};
window.addEventListener("load", function (event) {
  let code = document.querySelectorAll(".onloadCode");
  code.forEach(el => {
    let transformed = highlightKeywords(el.innerHTML, keys);
    el.innerHTML = transformed.trim();
  });
});

/***/ }),

/***/ "./js/constructos/_icons.js":
/*!**********************************!*\
  !*** ./js/constructos/_icons.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   icons_arrow_right: () => (/* binding */ icons_arrow_right),
/* harmony export */   icons_arrow_right_long: () => (/* binding */ icons_arrow_right_long),
/* harmony export */   icons_heart: () => (/* binding */ icons_heart)
/* harmony export */ });
/* harmony import */ var _node_modules_winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");
/* harmony import */ var _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/constructos.js */ "./node_modules/winnetoujs/src/constructos.js");



/**@private */
class icons_arrow_right_long_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * Create an icon **icons_arrow_right_long**
   * @param {object} [elements]
   * @param {any=} elements.class Class for the icon
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
<svg viewBox="0 0 512 512" id="icons_arrow_right_long-win-${identifier}" class="winIcons ${(elements_ === null || elements_ === void 0 ? void 0 : elements_.class) || ""}">
<path d="M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l370.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z"></path></svg>`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            icons_arrow_right_long: `icons_arrow_right_long-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`icons_arrow_right_long-win-${identifier}`, elements, options, icons_arrow_right_long_);
    return obj;
  };
} /**@private */
class icons_arrow_right_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * Create an icon **icons_arrow_right**
   * @param {object} [elements]
   * @param {any=} elements.class Class for the icon
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
<svg viewBox="0 0 448 512" id="icons_arrow_right-win-${identifier}" class="winIcons ${(elements_ === null || elements_ === void 0 ? void 0 : elements_.class) || ""}">
<path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"></path></svg>`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            icons_arrow_right: `icons_arrow_right-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`icons_arrow_right-win-${identifier}`, elements, options, icons_arrow_right_);
    return obj;
  };
} /**@private */
class icons_heart_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * Create an icon **icons_heart**
   * @param {object} [elements]
   * @param {any=} elements.class Class for the icon
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
<svg viewBox="0 0 512 512" id="icons_heart-win-${identifier}" class="winIcons ${(elements_ === null || elements_ === void 0 ? void 0 : elements_.class) || ""}">
<path d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"></path></svg>`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            icons_heart: `icons_heart-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`icons_heart-win-${identifier}`, elements, options, icons_heart_);
    return obj;
  };
}
const icons_arrow_right_long = new icons_arrow_right_long_().constructo;
const icons_arrow_right = new icons_arrow_right_().constructo;
const icons_heart = new icons_heart_().constructo;

/***/ }),

/***/ "./js/constructos/animation.js":
/*!*************************************!*\
  !*** ./js/constructos/animation.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logo: () => (/* binding */ logo)
/* harmony export */ });
/* harmony import */ var _node_modules_winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");
/* harmony import */ var _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/constructos.js */ "./node_modules/winnetoujs/src/constructos.js");



/**@private */
class logo_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} [elements]
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div class="logo" id="logo-win-${identifier}">
    <div class="pillar pillar_1" id="pillar_1-win-${identifier}">
      <div class="box box_1"></div>
      <div class="box box_2"></div>
      <div class="box box_3"></div>
    </div>
    <div class="pillar pillar_2" id="pillar_2-win-${identifier}">
      <div class="box box_1"></div>
      <div class="box box_2"></div>
      <div class="box box_3"></div>
    </div>
    <div class="pillar pillar_3" id="pillar_3-win-${identifier}">
      <div class="box box_1"></div>
      <div class="box box_2"></div>
      <div class="box box_3"></div>
    </div>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            logo: `logo-win-${identifier}`,
            pillar_1: `pillar_1-win-${identifier}`,
            pillar_2: `pillar_2-win-${identifier}`,
            pillar_3: `pillar_3-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`logo-win-${identifier}`, elements, options, logo_);
    return obj;
  };
}
const logo = new logo_().constructo;

/***/ }),

/***/ "./js/constructos/homeBody.js":
/*!************************************!*\
  !*** ./js/constructos/homeBody.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buttonSnippet: () => (/* binding */ buttonSnippet),
/* harmony export */   codeDiv: () => (/* binding */ codeDiv),
/* harmony export */   divOutputSnippet: () => (/* binding */ divOutputSnippet),
/* harmony export */   footer: () => (/* binding */ footer),
/* harmony export */   myDiv: () => (/* binding */ myDiv),
/* harmony export */   myImg: () => (/* binding */ myImg),
/* harmony export */   splash: () => (/* binding */ splash),
/* harmony export */   splash2: () => (/* binding */ splash2),
/* harmony export */   startHere: () => (/* binding */ startHere)
/* harmony export */ });
/* harmony import */ var _node_modules_winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");
/* harmony import */ var _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/constructos.js */ "./node_modules/winnetoujs/src/constructos.js");



/**@private */
class splash_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.text 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="splash-win-${identifier}" class="splash"><span>${elements_ === null || elements_ === void 0 ? void 0 : elements_.text}</span></div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            splash: `splash-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`splash-win-${identifier}`, elements, options, splash_);
    return obj;
  };
} /**@private */
class splash2_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.text 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="splash2-win-${identifier}" class="splash2"><span>${elements_ === null || elements_ === void 0 ? void 0 : elements_.text}</span></div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            splash2: `splash2-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`splash2-win-${identifier}`, elements, options, splash2_);
    return obj;
  };
} /**@private */
class startHere_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.onclick 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div class="startHere" id="startHere-win-${identifier}">
    <button onclick="${elements_ === null || elements_ === void 0 ? void 0 : elements_.onclick}">Start Here</button>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            startHere: `startHere-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`startHere-win-${identifier}`, elements, options, startHere_);
    return obj;
  };
} /**@private */
class codeDiv_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.title 
   * @param {any} elements.code 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="codeDiv-win-${identifier}" class="codeDiv">
    <div class="_title">${elements_ === null || elements_ === void 0 ? void 0 : elements_.title}</div>

    <div class="_content">
      <div class="_result" id="result-win-${identifier}"></div>
      <div class="codeOutput">
        <pre><code>${elements_ === null || elements_ === void 0 ? void 0 : elements_.code}</code></pre>
      </div>
    </div>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            codeDiv: `codeDiv-win-${identifier}`,
            result: `result-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`codeDiv-win-${identifier}`, elements, options, codeDiv_);
    return obj;
  };
} /**@private */
class divOutputSnippet_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} [elements]
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div class="divOutputSnippet" id="divOutputSnippet-win-${identifier}"></div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            divOutputSnippet: `divOutputSnippet-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`divOutputSnippet-win-${identifier}`, elements, options, divOutputSnippet_);
    return obj;
  };
} /**@private */
class myDiv_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.myDivStyle 
   * @param {any=} elements.content Set the text content of a div
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="myDiv-win-${identifier}" style="${elements_ === null || elements_ === void 0 ? void 0 : elements_.myDivStyle}">
    ${(elements_ === null || elements_ === void 0 ? void 0 : elements_.content) || ""}
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            myDiv: `myDiv-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`myDiv-win-${identifier}`, elements, options, myDiv_);
    return obj;
  };
} /**@private */
class buttonSnippet_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.onclick 
   * @param {any} elements.buttonText 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <button onclick="${elements_ === null || elements_ === void 0 ? void 0 : elements_.onclick}" class="buttonSnippet" id="buttonSnippet-win-${identifier}">
    ${elements_ === null || elements_ === void 0 ? void 0 : elements_.buttonText}
  </button>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            buttonSnippet: `buttonSnippet-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`buttonSnippet-win-${identifier}`, elements, options, buttonSnippet_);
    return obj;
  };
} /**@private */
class myImg_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.myImgStyle 
   * @param {any} elements.myImgSrc 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <img id="myImg-win-${identifier}" style="${elements_ === null || elements_ === void 0 ? void 0 : elements_.myImgStyle}" src="${elements_ === null || elements_ === void 0 ? void 0 : elements_.myImgSrc}" >
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            myImg: `myImg-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`myImg-win-${identifier}`, elements, options, myImg_);
    return obj;
  };
} /**@private */
class footer_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.heart 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="footer-win-${identifier}" class="footer">
    <span>Copyright &copy; 2024 Cedros Development</span>
    <span>WinnetouJs and its plugins are shared under the MIT license.</span>
    <span>Made with ${elements_ === null || elements_ === void 0 ? void 0 : elements_.heart} by Pamela Sedrez</span>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            footer: `footer-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`footer-win-${identifier}`, elements, options, footer_);
    return obj;
  };
}
const splash = new splash_().constructo;
const splash2 = new splash2_().constructo;
const startHere = new startHere_().constructo;
const codeDiv = new codeDiv_().constructo;
const divOutputSnippet = new divOutputSnippet_().constructo;
const myDiv = new myDiv_().constructo;
const buttonSnippet = new buttonSnippet_().constructo;
const myImg = new myImg_().constructo;
const footer = new footer_().constructo;

/***/ }),

/***/ "./js/constructos/wow.js":
/*!*******************************!*\
  !*** ./js/constructos/wow.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   footerWow: () => (/* binding */ footerWow),
/* harmony export */   logoText: () => (/* binding */ logoText),
/* harmony export */   navbar: () => (/* binding */ navbar),
/* harmony export */   wow: () => (/* binding */ wow)
/* harmony export */ });
/* harmony import */ var _node_modules_winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");
/* harmony import */ var _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/winnetoujs/src/constructos.js */ "./node_modules/winnetoujs/src/constructos.js");



/**@private */
class wow_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} [elements]
   * @param {any=} elements.class Define the class of wow
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div class="wow ${(elements_ === null || elements_ === void 0 ? void 0 : elements_.class) || ""}" id="wow-win-${identifier}"></div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            wow: `wow-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`wow-win-${identifier}`, elements, options, wow_);
    return obj;
  };
} /**@private */
class logoText_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} [elements]
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div class="logoText" id="logoText-win-${identifier}">
    <span class="title">WinnetouJs</span>
    <span class="subLogoText">Simple. Strong. Powerful.</span>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            logoText: `logoText-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`logoText-win-${identifier}`, elements, options, logoText_);
    return obj;
  };
} /**@private */
class navbar_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} [elements]
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="navbar-win-${identifier}" class="navbar">
    <div class="inner">
      <div class="left">
        <a href="https://google.com">Cedros Development</a>
      </div>
      <div class="right">
        <a href="">About</a>
        <a href="">GitHub</a>
        <a href="">Documentation</a>
        <a href="">Contact</a>
      </div>
    </div>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            navbar: `navbar-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`navbar-win-${identifier}`, elements, options, navbar_);
    return obj;
  };
} /**@private */
class footerWow_ extends _node_modules_winnetoujs_src_constructos_js__WEBPACK_IMPORTED_MODULE_1__.Constructos {
  // ========================================
  /**
   * 
   * @param {object} elements
   * @param {any} elements.getStarted 
   * @param {any} elements.icon 
   * @param {object} [options]
   * @param {any=} options.identifier
   */
  constructo = (elements, options) => {
    let identifier = this._mutableToString(options);
    identifier = this._getIdentifier(options ? identifier.identifier || 'notSet' : 'notSet');
    let elementsToString = this._mutableToString(elements);
    let component;
    let obj = {
      code(elements_) {
        return `
  <div id="footerWow-win-${identifier}" class="footerWow">
    <div class="btn" onclick="${elements_ === null || elements_ === void 0 ? void 0 : elements_.getStarted}">Get started ${elements_ === null || elements_ === void 0 ? void 0 : elements_.icon}</div>
  </div>
`;
      },
      /**
       * Create Winnetou Constructo        
       * @param  {object|string} output The node or list of nodes where the component will be created
       * @param  {object} [options] Options to control how the construct is inserted. Optional.
       * @param  {boolean} [options.clear] Clean the node before inserting the construct
       * @param  {boolean} [options.reverse] Place the construct in front of other constructs
       * @param {object} [options.vdom] Winnetou.vdom() fragment
       * @param {boolean} [options.replace] Replace a constructo
       */

      "create": (output, options) => {
        this.create(component, output, options);
        return {
          ids: {
            footerWow: `footerWow-win-${identifier}`
          },
          code: obj.code(elementsToString)
        };
      },
      constructoString: () => obj.code(elementsToString)
    };
    component = obj.code(elementsToString);
    this._saveUsingMutable(`footerWow-win-${identifier}`, elements, options, footerWow_);
    return obj;
  };
}
const wow = new wow_().constructo;
const logoText = new logoText_().constructo;
const navbar = new navbar_().constructo;
const footerWow = new footerWow_().constructo;

/***/ }),

/***/ "./node_modules/win-animate/src/animate.js":
/*!*************************************************!*\
  !*** ./node_modules/win-animate/src/animate.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anim: () => (/* binding */ anim)
/* harmony export */ });
/* harmony import */ var _winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../winnetoujs/src/winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");


/**
 * Create css animations
 * Credits to Copyright (c) 2020 Daniel Eden from https://animate.style
 * @param  {string} element tag("#myDiv"), class(".selectors") or tag("p")
 * @param  {string} animation animation name
 * @param  {"fast"|"faster"|"slower"|"slow"=} speed default **fast**
 *
 * Todo:
 * --> jsdoc speed params
 * --> query selector all
 */
function anim(element, animation, speed = "fast") {
  return new Promise((resolve, reject) => {
    const prefix = "animate__";
    const animationName = `${prefix}${animation}`;
    const node = _winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(element).getEl(element);
    _winnetoujs_src_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(element).addClass(`${prefix}animated`).addClass(`${prefix}${speed}`).addClass(animationName);

    // When the animation ends, we clean the classes and resolve the Promise
    function handleAnimationEnd() {
      node[0].classList.remove(`${prefix}animated`, animationName);
      node[0].removeEventListener("animationend", handleAnimationEnd);
      resolve("Animation ended");
    }
    node[0].addEventListener("animationend", handleAnimationEnd);
  });
}

/***/ }),

/***/ "./node_modules/winnetoujs/src/constructos.js":
/*!****************************************************!*\
  !*** ./node_modules/winnetoujs/src/constructos.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Constructos: () => (/* binding */ Constructos)
/* harmony export */ });
/* harmony import */ var _winnetou_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./winnetou.js */ "./node_modules/winnetoujs/src/winnetou.js");

class Constructos {
  _mutableToString(elements) {
    if (elements) {
      let retorno = JSON.parse(JSON.stringify(elements));
      Object.keys(elements).forEach(item => {
        if (typeof elements[item] === "object" && elements[item] !== null) {
          let mutable = elements[item].mutable;
          let val;
          _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.getMutable(mutable) || _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.getMutable(mutable) === "" ? val = _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.getMutable(mutable) : val = `Mutable "${mutable}" not initialized yet.`;

          /**
           * change mutable to string
           */
          retorno[item] = val;
        }
      });
      return retorno;
    } else {
      return elements;
    }
  }
  _saveUsingMutable(pureId, elements, options, method) {
    if (elements) {
      Object.keys(elements).forEach(item => {
        if (typeof elements[item] === "object" && elements[item] !== null) {
          if (!_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[elements[item].mutable]) _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[elements[item].mutable] = [];
          let obj = {
            pureId,
            elements,
            options,
            method
          };
          if (_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[elements[item].mutable].filter(x => x.pureId == pureId).length > 0) {
            // do nothing
          } else {
            _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[elements[item].mutable].push(obj);
          }
        }
      });
    }
    if (options) {
      Object.keys(options).forEach(item => {
        if (typeof options[item] === "object" && options[item] !== null) {
          if (!_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[options[item].mutable]) _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[options[item].mutable] = [];
          let obj = {
            pureId,
            elements,
            options,
            method
          };
          if (_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[options[item].mutable].filter(x => x.pureId == pureId).length > 0) {
            // do nothing
          } else {
            _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.usingMutable[options[item].mutable].push(obj);
          }
        }
      });
    }
  }

  /**
   * @protected
   * @param  {string=} identifier
   */
  _getIdentifier(identifier) {
    if (identifier != "notSet") return identifier;else return ++_winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.constructoId;
  }

  /**
   * Create Winnetou Constructo
   * @param  {string} component The component to be inserted
   * @param  {string | object} output The node or list of nodes where the component will be created
   * @param  {object} [options] Options to control how the construct is inserted. Optional.
   * @param  {boolean} [options.clear] Clean the node before inserting the construct
   * @param  {boolean} [options.reverse] Place the construct in front of other constructs
   * @param {object} [options.vdom] Winnetou.vdom() fragment
   * @param {boolean} [options.replace] Replace a constructo
   */

  create(component, output, options) {
    let frag;
    if (component.match(/^\s*?<tr|^\s*?<td|^\s*?<table|^\s*?<th|^\s*?<tbody|^\s*?<thead|^\s*?<tfoot/)) {
      let el = document.querySelectorAll(output);
      if (el.length === 0) {
        el = document.querySelectorAll("#" + output);
      }
      el.forEach(item => {
        // options
        if (options && options.clear) item.innerHTML = "";
        // @ts-ignore
        if (options && options.reverse) item.innerHTML = component + item.innerHTML;else {
          item.innerHTML += component;
        }
      });
    } else {
      frag = document.createRange().createContextualFragment(component);
      if (typeof output !== "object") {
        let el;
        if (options && options.vdom) {
          el = options.vdom.querySelectorAll(output);
          if (el.length === 0) {
            el = options.vdom.querySelectorAll("#" + output);
          }
        } else {
          el = document.querySelectorAll(output);
          if (el.length === 0) {
            el = document.querySelectorAll("#" + output);
          }
        }
        el.forEach(item => {
          if (options && options.replace) {
            _winnetou_js__WEBPACK_IMPORTED_MODULE_0__.Winnetou.replace(frag, item);
            return;
          }
          if (options && options.clear) item.innerHTML = "";
          // @ts-ignore
          if (options && options.reverse) item.prepend(frag);else {
            item.appendChild(frag);
          }
        });
      } else {
        if (options && options.clear) output.innerHTML = "";
        // @ts-ignore
        if (options && options.reverse) output.prepend(frag);else {
          output.appendChild(frag);
        }
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/winnetoujs/src/winnetou.js":
/*!*************************************************!*\
  !*** ./node_modules/winnetoujs/src/winnetou.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Winnetou: () => (/* binding */ Winnetou)
/* harmony export */ });
/* harmony import */ var _win_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../win.config.js */ "./win.config.js");
//@ts-ignore

class Winnetou_ {
  constructor() {
    /**
     * Incrementally id when no specific identifier is given
     *
     * @type {number}
     */
    this.constructoId = 0;

    /**
     * Variable that stores mutables who should not have been
     * persistent when updating the application
     * @protected
     * @type {array}
     */
    this.mutable = [];

    /**
     * List of constructos that are subscribed to the mutable listener
     *
     * @type {array}
     */
    this.usingMutable = [];

    /**
     * Object that will store routes on createRoutes
     * @protected
     * @type {object}
     */
    this.routes = {};

    /**
     * Object that will store the separated routes from createRoutes
     * @protected
     * @type {array}
     */
    this.paramRoutes = [];

    /**
     * Object that provides options when createRoutes, like
     * a standard function to be called when onBack is pressed
     * @protected
     * @type {object}
     */
    this.routesOptions = {};

    /**@private */
    this.storedEvents = [];

    /**@type {object} */
    this.strings = {};
    document.addEventListener("keydown", event => {
      if (event.which === 27) {
        history.go(-1);
      }
    });
    if (window.history && window.history.pushState) {
      window.onpopstate = event => {
        var _this$routesOptions;
        event.preventDefault();
        if (event.state == null) {
          this.routes["/"]();
        } else {
          try {
            this.callRoute(event.state);
          } catch (e) {
            console.error(`WinnetouJs Error, id: CR002\nGiven route is not available "${event.state}". Please verify given route. Original Error: ${e}`);
          }
        }
        if ((_this$routesOptions = this.routesOptions) !== null && _this$routesOptions !== void 0 && _this$routesOptions.onBack) {
          try {
            this.routesOptions.onBack();
          } catch (e) {
            console.error(`Winnetou Error, id: CR001\nThe onBack option in createRoutes() is not valid. Please use a function. \n\nOriginal Error: `, e);
          }
        }
      };
    } else {
      // $debug === "debug"
      //   ? console.log("History Api not allowed in this browser.")
      //   : null;
    }
    let theme = window.localStorage.getItem("theme");
    if (theme) {
      theme = JSON.parse(theme);
      let root = document.documentElement;
      Object.keys(theme).forEach(function (item) {
        root.style.setProperty(item, theme[item]);
      });
    } else {}
  }

  /**
   * Sets the value of passed winnetou mutable
   * @param {string} mutable string that represents a winnetou mutable
   * @param {string} value string value to be associated to mutable
   * @param {"notPersistent"|boolean} [localStorage] bool to save the state on the machine at the user, true by default. Use 'notPersistent' to be clear (and verbose).
   */
  setMutable(mutable, value, localStorage = true) {
    if (localStorage && localStorage !== "notPersistent") {
      window.localStorage.setItem(`mutable_${mutable}`, value);
    } else {
      this.mutable[mutable] = value;
    }
    if (this.usingMutable[mutable]) {
      /**
       * if the mutable has constructos
       * copy array to tmpArr
       */
      let tmpArr = this.usingMutable[mutable];
      this.usingMutable[mutable] = [];
      tmpArr.forEach(item => {
        /**
         * go through the tmpArr to handle constructos
         */
        let old_ = document.getElementById(item.pureId);
        if (old_ == null) return;
        let a = new item.method().constructo;
        let new_ = document.createRange().createContextualFragment(a(item.elements, item.options).constructoString());
        this.replace(new_, old_);
      });
    }
  }

  /**
   * initMutable initiates a mutable with
   * unique name saving it in
   * notPersistent mode and returning it name.
   * @param {string} value The string value of
   * mutable
   * @returns {string} unique name of mutable
   */
  initMutable(value) {
    let name = (new Date().getMilliseconds() * Math.random() * 10000).toFixed(0);
    this.setMutable(name, value, "notPersistent");
    return name;
  }

  /**
   * Gets the value of passed winnetou mutable
   * @param {string} mutable string that represents a winnetou mutable
   * @returns {string} value or null if not exists
   */
  getMutable(mutable) {
    if (window.localStorage.getItem(`mutable_${mutable}`) || window.localStorage.getItem(`mutable_${mutable}`) === "") {
      return window.localStorage.getItem(`mutable_${mutable}`);
    } else if (this.mutable[mutable] || this.mutable[mutable] === "") {
      return this.mutable[mutable];
    } else {
      return null;
    }
  }

  /**
   * Method to replace a constructo
   * @param {Element|DocumentFragment} new_ DOM Element
   * @param {Element|DocumentFragment} old_ DOM Element
   */
  replace(new_, old_) {
    if (old_ && old_.parentNode) {
      let ele_ = old_.parentNode;
      ele_.replaceChild(new_, old_);
    }
  }

  /**
   * Select the indicated element.
   * If selector is a class or tag and user request for
   * a get function (e.g. getScrollTop()) the returned value
   * will be of the first occurrence ([0]) of matches.
   * @param {string} selector html element. A tag, id ou class.
   */
  select(selector = "") {
    var el;
    const obj = {
      /**
       * @param {any} selector
       */
      getEl(selector) {
        if (el) return el;
        if (typeof selector == "object") {
          return [selector];
        } else {
          //
          if (selector.includes(" ")) {
            return document.querySelectorAll(selector);
          }
          //
          else if (selector.match(/^\#/)) {
            selector = selector.replace("#", "");
            return [document.getElementById(selector)];
          }
          //
          else if (selector.match(/^\./)) {
            selector = selector.replace(".", "");
            return Array.from(document.getElementsByClassName(selector));
          }
          //
          else {
            if (selector.includes("-win-")) {
              selector = selector.replace("#", "");
              return [document.getElementById(selector)];
            }
            let arr = Array.from(document.getElementsByTagName(selector));
            if (arr.length === 0) {
              return [document.getElementById(selector)];
            } else {
              return arr;
            }
          }
        }
      },
      /**
       * remove constructo from the DOM
       */
      remove() {
        el.forEach(item => {
          item.remove();
        });
        return this;
      },
      /**
       * set inner html of constructo
       * @param {string} htmlContentString the html string to be inserted
       */
      html(htmlContentString) {
        el.forEach(item => {
          item.innerHTML = htmlContentString;
        });
        return this;
      },
      /**
       * get the inner html of constructo
       */
      getHtml() {
        return el[0].innerHTML;
      },
      /**
       * get inner text of constructo
       */
      getText() {
        return el[0].textContent;
      },
      /**
       * append html to the end of constructo's html
       * @param {string} htmlContentString the html string to be inserted
       */
      append(htmlContentString) {
        el.forEach(item => {
          item.innerHTML += htmlContentString;
        });
        return this;
      },
      /**
       * prepend html to the start of constructo's html
       * @param {string} htmlContentString the html string to be inserted
       */
      prepend(htmlContentString) {
        // el.innerHTML = texto + el.innerHTML;
        el.forEach(item => {
          item.innerHTML = htmlContentString + item.innerHTML;
        });
        return this;
      },
      /**
       * Changes the css of constructo or DOM component
       * @tutorial https://www.w3schools.com/JSREF/dom_obj_style.asp
       * @param {string | number} property The Style object represents an individual style statement.
       * @param {string | number} value The value. If it is a number, winnetou will assume that it's a short hand to 'px'.
       */
      css(property, value) {
        let valueString = value;
        el.forEach(item => {
          if (typeof value == "number") valueString = value + "px";
          item.style[property] = valueString;
        });
        return this;
      },
      /**
       * Add the class if not added yet, remove the class if already added.
       * @param {string} className name of class
       */
      toggleClass(className) {
        el.forEach(item => {
          item.classList.toggle(className);
        });
        return this;
      },
      /**
       * Add a class
       * @param {string} className name of class
       */
      addClass(className) {
        el.forEach(item => {
          item.classList.add(className);
        });
        return this;
      },
      /**
       * Removes a class
       * @param {string} className name of class
       */
      removeClass(className) {
        el.forEach(item => {
          item.classList.remove(className);
        });
        return this;
      },
      /**
       * Hide a constructo
       */
      hide() {
        el.forEach(item => {
          item.classList.add("winnetou_display_none");
        });
        return this;
      },
      /**
       * Show a constructo
       */
      show() {
        el.forEach(item => {
          item.classList.remove("winnetou_display_none");
          if (getComputedStyle(item).display == "none") {
            item.style.display = "initial";
          }
        });
        return this;
      },
      /**
       * Get width of a constructo
       */
      getWidth() {
        return el[0].getBoundingClientRect().width;
      },
      /**
       * Get height of a constructo
       */
      getHeight() {
        return el[0].getBoundingClientRect().height;
      },
      /**
       * Get left of a constructo
       */
      getLeft() {
        return el[0].offsetLeft;
      },
      /**
       * Get top of a constructo
       */
      getTop() {
        return el[0].offsetTop;
      },
      /**
       * Get global position of a constructo
       */
      getGlobalPosition() {
        return el[0].getBoundingClientRect();
      },
      /**
       * Get value of a constructo
       */
      getVal() {
        return el[0].value;
      },
      /**
       * Sets a value to a constructo, also fire a change event
       * @param {string} value The value.
       */
      setVal(value) {
        el.forEach(item => {
          item.value = value;
          if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("change", false, true);
            item.dispatchEvent(evt);
          } else item.fireEvent("onchange");
        });
        return this;
      },
      /**
       * Sets an attr to a constructo
       * @param  {string} attr name of attribute
       * @param  {string} value the values
       */
      setAttr(attr, value) {
        el.forEach(item => {
          item.setAttribute(attr, value);
        });
        return this;
      },
      /**
       * Gets the attr
       * @param  {string} attr attribute name
       */
      getAttr(attr) {
        return el[0].getAttribute(attr);
      },
      /**
       * Returns checked property of a constructo
       */
      isChecked() {
        return el[0].checked;
      },
      /**
       * Gets the file of a input type file
       *
       * @typedef {Object} File_
       * @property {number} lastModified
       * @property {Date} lastModifiedDate
       * @property {string} name
       * @property {number} size
       * @property {string} type
       *
       * @returns {File_}
       */
      getFile() {
        return el[0].files[0];
      },
      /**
       * Gets file array of a input type file
       *
       * @returns {Array.<File_>}
       */
      getFiles() {
        return el[0].files;
      },
      /**
       * get scrollTop of a constructo
       */
      getScrollTop() {
        return el[0].scrollTop;
      },
      disable() {
        el[0].disabled = true;
        return this;
      },
      enable() {
        el[0].disabled = false;
        return this;
      }
    };
    el = obj.getEl(selector);
    if (el[0] === null) {
      console.warn(`WinnetouJs Warning: The provided element selector (${selector}) does not exists in DOM. Winnetou is skipping this fatal error, but verify.`);
      let void_ = this.vdom();
      void_.appendChild(document.createRange().createContextualFragment("<p class='foo'>"));
      el = void_.querySelectorAll(".foo");
    }
    return obj;
  }

  /**
   * Method for store dynamic Winnetou Routes
   * @param  {object} obj
   * @param  {object} [options]
   * @param  {function=} options.onBack Function that will be called when user fires back button
   * @param  {function=} options.onGo Function that will be called when user triggers a route
   */
  createRoutes(obj, options) {
    this.routes = obj;
    this.routesOptions = options;
    Object.keys(this.routes).forEach(route => {
      let segment = route.split("/");
      let size = segment.length;
      this.paramRoutes.push({
        root: route,
        size
      });
    });
  }

  /**
   * Navigate between Winnetou routes
   * @param {string} url Path already defined in createRoutes method
   * @param {boolean} pushState To use navigate without change URL
   */
  navigate(url, pushState = true) {
    if (window.history && window.history.pushState) {
      var _this$routesOptions2;
      this.callRoute(url);
      pushState && this.pushState(url);
      if ((_this$routesOptions2 = this.routesOptions) !== null && _this$routesOptions2 !== void 0 && _this$routesOptions2.onGo) {
        try {
          this.routesOptions.onGo();
        } catch (e) {
          console.error(`Winnetou Error, id: CR001\nThe onGo option in createRoutes() is not valid. Please use a function. \n\nOriginal Error: `, e);
        }
      }
    }
  }

  /**
   * Allows WinnetouJs to pass between pages on the app.
   * Needs a valid const routes already set.
   * Do not changes URL.
   * @param {string} route function already set in createRoutes
   */
  pass(route) {
    if (window.history && window.history.pushState) {
      var _this$routesOptions3;
      this.callRoute(route);
      this.pushStateInteraction(route);
      if ((_this$routesOptions3 = this.routesOptions) !== null && _this$routesOptions3 !== void 0 && _this$routesOptions3.onGo) {
        try {
          this.routesOptions.onGo();
        } catch (e) {
          console.error(`Winnetou Error, id: CR001\nThe onGo option in createRoutes() is not valid. Please use a function. \n\nOriginal Error: `, e);
        }
      }
    } else {
      // this.debug === "debug"
      //   ? console.log("History Api not allowed in this browser.")
      //   : null;
    }
  }

  /** @private */
  pushStateInteraction(func) {
    // history.replaceState(func, null);
    history.pushState(func, null);
  }
  /** @private
   * W.navigate('/profile/azul')
   */
  callRoute(url) {
    try {
      let splittedUrl = url.split("/");
      let size = splittedUrl.length;
      let filter = this.paramRoutes.filter(data => data.size === size);
      if (filter.length === 0) {
        this.notFound();
      }
      for (let i = 0; i < filter.length; i++) {
        let root = filter[i].root.split("/");
        let correctMatch = true;
        let paramStore = [];
        for (let j = 0; j < root.length; j++) {
          if (root[j] !== splittedUrl[j]) {
            correctMatch = false;
            if (root[j].includes(":")) {
              correctMatch = true;
              paramStore.push(splittedUrl[j]);
            } else {
              correctMatch = false;
              break;
            }
          }
        }
        if (correctMatch) {
          this.routes[filter[i].root](...paramStore);
          return;
        } else if (i === filter.length - 1) {
          this.notFound();
        }
      }
    } catch (e) {
      console.log(e);
      this.notFound();
    }
  }

  /** @private */
  notFound() {
    try {
      this.routes["/404"]();
    } catch (e) {
      this.select("body").prepend(`
      
      <p onclick="Winnetou.select('.winnetouNotFoundDefault').hide()" style="width:100%;padding:15px;color:white;background-color:red;cursor:pointer;" class='winnetouNotFoundDefault'>
        Page not found. Click to close.
      </p>
      `);
    }
  }

  /** @private */
  pushState(url) {
    try {
      history.pushState(url, "", url);
    } catch (e) {
      history.pushState(url, null);
    }
  }

  /**
   * Winnetou function storage method
   * @param  {function} function_ Function to be called when event fires
   * @param  {string} args A list of arguments comma separated
   */
  fx(function_, args = "") {
    let name = "winnetouFx" + (new Date().getMilliseconds() * Math.random() * 10000).toFixed(0);
    window[name] = function_;
    return `${name}(${args})`;
  }

  /**
   * Method for handle events.
   * @param  {string} event Event name, eg. 'click' or 'mouseover'
   * @param  {string} elementSelector A valid element selector
   * @param  {function} callback callback function
   */
  listen(event, elementSelector, callback) {
    try {
      document.querySelector("#" + elementSelector).addEventListener(event, e => {
        callback(e);
      });
    } catch (e) {
      document.querySelectorAll(elementSelector).forEach(x => {
        x.addEventListener(event, e => {
          callback(e);
        });
      });
    }
  }

  /**
   * @deprecated
   * This method proved to be inefficient
   * in object-oriented environments.
   * It will be removed in the next
   * major version of WinnetouJs.
   * Use listen instead.
   * @description
   * Method for handle events.
   * This method will add an event listener to entire document
   * associating elementSelector to the event.
   * In this way the construct can be created after the creation
   * of the event listener which will still fire correctly.
   *
   *
   * @param  {string} eventName Name of event, eg. "keyup"
   * @param  {string} elementSelector DOM selector, id, class or tag
   * @param  {function} callback function to be called when trigger event, eg. e=>{}
   * @param  {object} [options]
   * @param  {Array.<string>} [options.remove] Array of child elements that will not be activated by the action trigger.
   */
  on(eventName, elementSelector, callback, options) {
    let callbackBck;
    /**
     * This will test event to be not duplicated.
     * this.storedEvents contains all events created by winnetoujs.
     * If it already exists then return, exiting algorithm.
     */
    let test = this.storedEvents.filter(data => data.eventName === eventName && data.elementSelector === elementSelector && data.callback === callback.toString());
    // if test filter returned a result, then exit.
    if (test.length > 0) {
      return;
    }
    // else continue and store the event
    this.storedEvents.push({
      eventName,
      elementSelector,
      callback: callback.toString()
    });
    switch (eventName) {
      /**
       * If the provided event is a scroll event, it must be
       * associated with element and not to document.
       * In this case the returned value is the event
       * which can be accessed by e.target.scrollTop
       * or Winnetou.select(e.target)
       */
      case "scroll":
        try {
          document.querySelector("#" + elementSelector).addEventListener("scroll", e => {
            callback(e);
          });
        } catch (e) {
          document.querySelector(elementSelector).addEventListener("scroll", e => {
            callback(e);
          });
        }
        break;

      /**
       * On touch devices sets event handler to touchstart
       * fallbacks to click
       */
      case "click":
        eventName = "ontouchstart" in document.documentElement ? "touchstart" : "click";
        document.addEventListener(eventName, eventHandler);
        break;

      /**
       * if it is not a special event
       * finally add the event listener to document, associating 'eventHandler'.
       */
      default:
        document.addEventListener(eventName, eventHandler);
        break;
    }

    /**
     * This function will be stored in EventListener with
     * provided elementSelector
     * @param {any} e EventListener
     */
    function eventHandler(e) {
      // if elementSelector is an id but without #
      let elementSelectorId = "#" + elementSelector;

      /**
       * https://developer.mozilla.org/pt-BR/docs/Web/API/Element/closest
       *
       * First the algorithm will search if the clicked element (e.target)
       * owns an element that matches elementSelector
       * if not, exits.
       */
      if (!e.target.closest(elementSelector)) {
        try {
          if (!e.target.closest(elementSelectorId)) {
            return;
          }
        } catch (e) {
          return;
        }
      }

      // boolean that controls if callback function
      // can be fired
      let shouldContinue = true;

      /**
       * e.path contains all child elements of trigger
       * element, so it will be scanned.
       */
      let path = e.path || e.composedPath && e.composedPath();
      for (let c = 0; c < path.length; c++) {
        // item now is the deepest element
        let item = path[c];

        /**
         * if options.remove was provided
         * needs to check if a child element
         * must be excluded
         */
        if (options && options.remove) {
          // remove scan
          for (let w = 0; w < options.remove.length; w++) {
            try {
              // if match, switch control to false
              if (item.matches(options.remove[w])) {
                shouldContinue = false;
              }

              // if not match, try an selector id (#id)
              if (item.matches("#" + options.remove[w])) {
                shouldContinue = false;
              }
            } catch (e) {}
          }
        }

        /**
         * check if item matches elementSelector
         */
        try {
          if (item.matches(elementSelector)) {
            /**
             * if match, trigger the stored callback
             * providing the element as parameter (item)
             * if shouldContinue is true
             */
            shouldContinue && callback(item);
          } else if (item.matches(elementSelectorId)) {
            /**
             * if not match, try forcing id selector (#id)
             */
            shouldContinue && callback(item);
          }
        } catch (e) {}
      }
    }
  }

  /**
   * @deprecated This method will be removed in the next major version
   * due to its inefficiency when handling multiple callbacks.
   * Use listen instead.
   * @description
   * On touch devices sets event handler to touchstart
   * fallbacks to click
   * @param  {string} selector DOM selector, id, class or tag
   * @param  {function} callback function to be called when trigger event, eg. e=>{}
   * @param  {object} [options]
   * @param  {Array.<string>} [options.remove]
   */
  click(selector, callback, options) {
    var clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
    this.on(clickHandler, selector, el => {
      callback(el);
    }, options);
  }

  /**
   * Activate translations, Must be called when application starts.
   * @param {function} next_ callback to app start.
   * @param {object} class_ the Strings class
   * @example
   * Winnetou.lang(Strings, render);
   *
   * @deprecated
   */

  async lang(class_, next_) {
    if (!window.localStorage.getItem("lang")) return next_();
    let This = class_;

    // if (!Config?.folderName) {
    //   console.error(
    //     "WinnetouJs Translation Miss Configuration Error:You have to specify the name of winnetou folder in order to use the translations;"
    //   );

    //   return next_();
    // }

    // if (Config.folderName === "/") Config.folderName = "";

    let defaultLang = _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] === null || _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] === void 0 ? void 0 : _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultLang;
    let localLang = window.localStorage.getItem("lang");
    if (localLang) defaultLang = localLang;
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 404) {
        console.log("\nThe file ", `./translations/${defaultLang}.xml`, "are not found");
        window.localStorage.removeItem("lang");
        location.reload();
      }
      if (this.readyState == 4 && this.status == 200) {
        try {
          let xml = this.responseXML;
          let el = xml.getElementsByTagName("winnetou");
          let lines = el[0].childNodes;
          lines.forEach(item => {
            if (item.nodeName != "#text") {
              This[item.nodeName] = item.textContent;
            }
          });
        } catch (e) {
          console.log("The translation file ", `./translations/${defaultLang}.xml`, " seems to be empty or incorrect.", e.message);
        }
        return next_();
      }
    };
    xhttp.open("GET", `./translations/${defaultLang}.xml`, true);
    xhttp.send();
  }

  /**
   * The updateTranslation method is only called when user
   * already changed language with `changeLang()` method.
   * when this happens, an local storage variable `lang`
   * is created, changing all app language.
   * If `lang` is not defined yet, this method
   * does nothing.
   *
   * @param {object} class_ the import from _strings.js
   * @example
   * import _strings from "./_strings.js";
   * Winnetou.updateTranslations(_strings).then(() => render());
   * @returns
   */
  async updateTranslations(class_) {
    /**
     * Function to get json from API
     * @param {string} url API Endpoint
     */
    const get = url => {
      return new Promise((resolve, reject) => {
        fetch(url, {
          method: "GET"
        }).then(function (response) {
          if (response.ok) {
            return response.json();
          } else {
            return reject("Translation file not found. Code error kj438dj.");
          }
        }).then(function (data) {
          return resolve(data);
        }).catch(function (error) {
          return reject("Translation file not found. Code error kj438dssj.");
        });
      });
    };
    return new Promise(async (resolve, reject) => {
      if (!window.localStorage.getItem("lang")) return resolve();
      let This = class_;
      if (!(_win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] !== null && _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] !== void 0 && _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath)) {
        console.error("WinnetouJs updateTranslations Miss Configuration Error:You have to specify the public path in order to use the translations;");
        _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath = "";
      }
      if (_win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath === "/") _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath = "";
      let defaultLang = _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] === null || _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"] === void 0 ? void 0 : _win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultLang;
      let localLang = window.localStorage.getItem("lang");
      if (localLang) defaultLang = localLang;
      let data;
      try {
        data = await get(`${_win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath}/translations/${defaultLang}.json`);
      } catch (e) {
        console.warn(`Lang error. Reloading...


The file '${_win_config_js__WEBPACK_IMPORTED_MODULE_0__["default"].publicPath}/translations/${defaultLang}.json' was not found. Did you set publicPath in win.config.js and created json translation file?`);
        window.localStorage.removeItem("lang");
        setTimeout(() => {
          // to use new cycle
          location.reload();
        }, 200);
      }

      // let file = JSON.parse(data);

      Object.keys(data).map(key => {
        let value = data[key];

        // replace all values of _strings.js object
        This[key] = value;
      });
      return resolve();
    });
  }

  /**
   * Change language
   * @param lang string language
   */
  changeLang(lang) {
    window.localStorage.setItem("lang", lang);
    location.reload();
  }
  /**
   * Change application css
   * @param  {object} theme New theme
   */
  newTheme(theme) {
    let root = document.documentElement;
    Object.keys(theme).forEach(function (item) {
      root.style.setProperty(item, theme[item]);
    });
    window.localStorage.setItem("theme", JSON.stringify(theme));
  }
  vdom() {
    return document.createDocumentFragment();
  }
  create(frag, output, options) {
    let el = document.querySelectorAll(output);
    if (el.length === 0) {
      el = document.querySelectorAll("#" + output);
    }
    el.forEach(item => {
      // options
      if (options && options.clear) item.innerHTML = "";
      // @ts-ignore
      if (options && options.reverse) item.prepend(frag);else {
        item.appendChild(frag);
      }
    });
  }
}
const Winnetou = new Winnetou_();

/***/ }),

/***/ "./win.config.js":
/*!***********************!*\
  !*** ./win.config.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @type {import('./interfaces').IWinConfig}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  constructosPath: "./constructos",
  constructosOut: "./js/constructos",
  entry: "./js/app.js",
  out: "./release",
  sass: "./sass",
  defaultLang: "en-us",
  publicPath: "/",
  cssOut: "./release",
  icons: "./icons"
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var winnetoujs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! winnetoujs */ "./node_modules/winnetoujs/src/winnetou.js");
/* harmony import */ var _constructos_animation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructos/animation.js */ "./js/constructos/animation.js");
/* harmony import */ var _constructos_wow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructos/wow.js */ "./js/constructos/wow.js");
/* harmony import */ var _node_modules_win_animate_src_animate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node_modules/win-animate/src/animate.js */ "./node_modules/win-animate/src/animate.js");
/* harmony import */ var _constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constructos/homeBody.js */ "./js/constructos/homeBody.js");
/* harmony import */ var _code_highlighter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./code_highlighter.js */ "./js/code_highlighter.js");
/* harmony import */ var _constructos_icons_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constructos/_icons.js */ "./js/constructos/_icons.js");







let wowContainer = (0,_constructos_wow_js__WEBPACK_IMPORTED_MODULE_2__.wow)({}).create("#app").ids.wow;
(0,_constructos_wow_js__WEBPACK_IMPORTED_MODULE_2__.navbar)().create(wowContainer);
(0,_constructos_wow_js__WEBPACK_IMPORTED_MODULE_2__.footerWow)({
  icon: (0,_constructos_icons_js__WEBPACK_IMPORTED_MODULE_6__.icons_arrow_right_long)().constructoString(),
  getStarted: winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.fx(() => location.href = "/docs/get-started")
}).create(wowContainer);
(0,_constructos_wow_js__WEBPACK_IMPORTED_MODULE_2__.logoText)().create(wowContainer);
let winnetouLogo = (0,_constructos_animation_js__WEBPACK_IMPORTED_MODULE_1__.logo)({}).create(wowContainer);
(async () => {
  await (0,_node_modules_win_animate_src_animate_js__WEBPACK_IMPORTED_MODULE_3__.anim)(winnetouLogo.ids.pillar_1, "zoomIn");
  winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(winnetouLogo.ids.pillar_2).css("visibility", "visible");
  await (0,_node_modules_win_animate_src_animate_js__WEBPACK_IMPORTED_MODULE_3__.anim)(winnetouLogo.ids.pillar_2, "zoomIn");
  winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(winnetouLogo.ids.pillar_3).css("visibility", "visible");
  await (0,_node_modules_win_animate_src_animate_js__WEBPACK_IMPORTED_MODULE_3__.anim)(winnetouLogo.ids.pillar_3, "zoomIn");
  -setTimeout(() => {
    winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(winnetouLogo.ids.pillar_1).addClass("animation");
    winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(winnetouLogo.ids.pillar_2).addClass("animation");
    winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(winnetouLogo.ids.pillar_3).addClass("animation");
  }, 500);
})();
(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.splash)({
  text: "Try the simplicity of WinnetouJs, the indie way to create vanilla javascript web applications"
}).create("#app");
let code1 = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.codeDiv)({
  title: "Simple button increment example",
  code: (0,_code_highlighter_js__WEBPACK_IMPORTED_MODULE_5__.transform)(`
let clicks = 0,
 text = Winnetou.initMutable(\`You clicked me \${clicks} times.\`),
 btn = button({
  text: { mutable: text },
  onclick: Winnetou.fx(() => {
    clicks++;
    Winnetou.setMutable(text, \`You clicked me \${clicks} times.\`);
  }),
}).create('#app');`)
}).create("#app").ids.result;
let output = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.divOutputSnippet)().create(code1);
let clicks = 0;
let text = winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.initMutable(`You clicked me ${clicks} times.`);
let btn = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.buttonSnippet)({
  buttonText: {
    mutable: text
  },
  onclick: winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.fx(() => {
    clicks++;
    winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.setMutable(text, `You clicked me ${clicks} times.`);
  })
}).create(output.ids.divOutputSnippet);

// ------------------------

(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.splash)({
  text: "Feel the strength of an integrated workflow to build web components: constructos"
}).create("#app");
let code2 = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.codeDiv)({
  title: "Example of creating dynamic lists",
  code: (0,_code_highlighter_js__WEBPACK_IMPORTED_MODULE_5__.transform)(`// myComponents.html
&ltwinnetou&gt
  &ltdiv id=&quot[[myDiv]]&quot&gt
    {{?content%Set the text content of a div}}
  &lt/div&gt
&lt/winnetou&gt
&ltwinnetou&gt
  &ltimg id=&quot[[myImg]]&quot src=&quot{{myImgSrc}}&quot /&gt
&lt/winnetou&gt

// app.js
for (let i = 0; i < 10; i++) {
  let card = myDiv().create('#app').ids.myDiv;
  myImg({
    myImgSrc: \`https://api.multiavatar.com/mary\${i}.png\`
  }).create(card);
  myDiv({
    content: "Mary " + i
  }).create(card);
}`)
}).create("#app").ids.result;
let output2 = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.myDiv)({
  myDivStyle: `
  width:100%;
  max-height:100%;
  overflow-y:scroll;
  padding:20px;
  `
}).create(code2).ids.myDiv;
for (let i = 0; i < 10; i++) {
  let card = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.myDiv)({
    myDivStyle: "display:flex;border:2px solid #777;padding:20px;border-radius:5px;margin:5px; align-items:center;"
  }).create(output2).ids.myDiv;
  (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.myImg)({
    myImgSrc: `../images/avatars/mary${i}.png`,
    myImgStyle: "width:50px;"
  }).create(card);
  (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.myDiv)({
    myDivStyle: "margin-left:10px;color:#ccc;",
    content: "Mary " + i
  }).create(card);
}

// ------------------------

(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.splash)({
  text: "Get the power of not relying on jsx, typescript and/or any other type of javascript abstraction"
}).create("#app");
let code3 = (0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.codeDiv)({
  title: "Using jsdoc to get type checking in webstorm and vscode",
  code: (0,_code_highlighter_js__WEBPACK_IMPORTED_MODULE_5__.transform)(`/**
  * Changes background color
  * @param {string} class_ Set class name to toggle
  */
 const toggleBg = class_ => Winnetou.select('#app').toggleClass(class_)
 
 button({
   buttonText: "Change my color",
   onclick: Winnetou.fx(() => toggleBg("alt")),
 }).create('#app');`)
}).create("#app").ids.result;

/**
 * Changes background color
 * @param {string} class_ Set class name to toggle
 */
const toggleBg = class_ => winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.select(code3).toggleClass(class_);
(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.buttonSnippet)({
  buttonText: "Change my color",
  onclick: winnetoujs__WEBPACK_IMPORTED_MODULE_0__.Winnetou.fx(() => toggleBg("alt"))
}).create(code3);

// ------------------------

// ------------------------

(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.splash)({
  text: "Welcome to your new web development home. Your code flow, simplified."
}).create("#app");
(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.splash2)({
  text: "You don't need to \"learn\" WinnetouJs, it's pure vanilla javascript. If you know js you know winnetou. Get started today."
}).create("#app");
(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.startHere)({
  onclick: ""
}).create("#app");
// ------------------------

(0,_constructos_homeBody_js__WEBPACK_IMPORTED_MODULE_4__.footer)({
  heart: (0,_constructos_icons_js__WEBPACK_IMPORTED_MODULE_6__.icons_heart)().constructoString()
}).create("#app");
})();

/******/ })()
;
//# sourceMappingURL=winnetouBundle.min.js.map